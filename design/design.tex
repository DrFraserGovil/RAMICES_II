\documentclass[a4paper,10pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{tikz-uml}
\usepackage{lscape}
\usepackage{pgfplots}
\usepackage{hyperref}
% \sloppy
% \hyphenpenalty 10000000
\setlength\parindent{0pt}
\setlength\parskip{10pt}
\usepackage{soul} 
\usepackage{xifthen}

\newboolean{completed}
\setboolean{completed}{false}
\newboolean{firstpass}
\setboolean{firstpass}{true}

\hypersetup{
    colorlinks,
    linkcolor={black},
    citecolor={blue!50!black},
    urlcolor={blue!90!black},
	filecolor={blue!90!black}
}

\title{RAMICES III}
\author{(JF)$^2$G}
\def\d{\mathrm d}
\newcommand\fitem[2]
			{
				\textbf{#1:} #2
			}
			\newcommand\citem[3][0]
			{
				\ifthenelse{\equal{#1}{1} \OR \boolean{completed}}
				{
					\ifthenelse{\NOT \boolean{firstpass}}
					{
						\item {\fitem{\st{#2}}{\st{#3}}}
					}{
					}
				}
				{
					\ifthenelse{\boolean{firstpass}}
					{\item \fitem{#2}{#3}}{}
					
				}
			}
			\def\emptyItem
			{
				\item[] \vspace{-20pt}
			}
			\newcommand\cparent[4][0]
			{
				\if#11
					\setboolean{completed}{true}
				\fi

				\ifthenelse{\equal{#1}{0} \AND \boolean{firstpass}}
				{
					\citem[#1]{#2}{#3}
					\begin{enumerate}
						#4
						\emptyItem{}
					\end{enumerate}
					\setboolean{firstpass}{false}
					\begin{enumerate}
						#4
						\emptyItem{}						
					\end{enumerate}
					\setboolean{firstpass}{true}
				}
				{
					\ifthenelse{\boolean{firstpass}}
					{}
					{
						\ifthenelse{\equal{#1}{1}}
						{
						\citem[#1]{#2}{#3}
					\begin{enumerate}
						#4
						\emptyItem{}
					\end{enumerate}
						}{}
					}
				}
				\setboolean{completed}{false}
			}

			\newcommand\fancyList[1]
			{
				\begin{enumerate}
					\setboolean{firstpass}{true}
					#1
					\setboolean{firstpass}{false}
					#1
					\emptyItem{}
				\end{enumerate}
			}

			\usepackage[framemethod=tikz]{mdframed}
			\mdfdefinestyle{mpdframe}{
				frametitlebackgroundcolor   =black!15,
				frametitlerule          =true,
					roundcorner     =10pt,
					middlelinewidth     =1pt,
					innermargin     =.20cm,
					outermargin     =0.2cm,
					innerleftmargin     =0.2cm,
					innerrightmargin        =0.2cm,
					innertopmargin      =\topskip,
					innerbottommargin   =\topskip,
						}
			%   Studies
			\mdfdefinestyle{a}{%
					style=mpdframe,
					frametitle={Aside},
				}
			\newmdenv[style=a]{aside}
\begin{document}
% \setcounter{tocdepth}{2}
\maketitle
% \tableofcontents
	\def\RTwo{\texttt{R2}}
	

		\section*{Oh no, here we go again}

			We're refactoring RAMICES. Again.

			Why? Why would we do this to ourselves? What on God's Green Earth would drive us to such extreme lengths, when we could be doing so much else with our lives?
			
			The long story short is that more than 3 years have passed since it was written: we've both learned a lot. There's also been a bit of space between its original design and the idea that it would have a lifetime outside of my thesis\footnote{My thesis made some grand claims about it being a general purpose code. Lies.}

			In particular, there was one big black mark that has hung over RAMICES II (\RTwo) which was the stellar catalogue synthesis: Jenny has since found a whole bunch of stuff that's basically held together by hope and good intentions - or simply not held together at all. 

			\subsubsection*{Don't Be So Dramatic}

				I'm being deliberately hyperbolic here. It's worth noting in writing that I don't expect this to be anywhere near as painful as the original Great Refactoring. \RTwo{} is leagues ahead of its predecessor in terms of being able to be read by a mortal mind without causing it to fragment into a trillion tiny pieces. 

				If all goes well, this will be a nice quick project that results in a vastly superior end product. Make a wish, children!

				
				
			\subsubsection*{What This Document Is}

				Ensuring that this new code update is swift, and non-brain melting means doing some work up front: an up-front statement of intent, and a record of our internal thoughts and decisions which lead to certain elements of the design. That way, when someone says `why is $X$ like $Y$', they can look at this document to understand those decision.

			\subsubsection*{What it isn't}
				
				This is \textbf{not} a checklist of everything that needs doing on a day to day basis. There will be a list of things that we think of at the start, but as new challenges arise, we'll track them using \href{{https://github.com/users/DrFraserGovil/projects/3/views/1}}{a more suitable project tracking system.}

		\newpage
		\section{Up Front Thoughts}

			
			The main argument we should justify in this document is why a complete code refactor is necessary, rather than simply `tidying up' the old code.

			I think we highlight that the following four things are the main target of RAMICES III:
			\begin{enumerate}
				\item \textbf{A Revised Population-Tracking Method} 
				
				\href{theory.pdf}{An attached theory document} details a major overhaul of the current mass-binning of stars. This requires a complete rewrite of the internal logic of the stellar tracking system

				\item \textbf{A Revised Stellar Catalogue System}
				
				The current system of synthesising stellar catalogues and selection functions has never been to my satisfaction.
				\item \textbf{Improved Modularity} 
				
				\RTwo{} is a drastic improvement over its predecessor in terms of being able to `plug and play' new modules\footnote{This is evidence by Jenny's NSD work, which remains astounding to me that it worked at all.}, but many things are still somewhat hardcoded and assumed, simply because they were necessary for the Thesis development.
				\item \textbf{More Sophisticated Development}
				
				\RTwo{} was written in three months of PhD-Crunch. It is not a particularly pretty sight, there is little to no internal documentation, and things such as the git history are best left unspoken-of. We should like to write these things with a mind to future maintenance and use by people who still have their sanity.
			\end{enumerate}

			\subsection{Other Design Thoughts}

				\subsubsection{Test-Driven Development}

					A risk of scientific software design is that you end up attributing some intriguing scientific interpretation to a software bug. Both \texttt{R1} and \RTwo{} are highly state-dependent systems with a lot of external state-modification. This can make debugging the system highly difficult, and allows for the possibility of strange and unusual software bugs. 
					
					When refactoring the code we should strive to adhere to the following principles:
					\begin{itemize}
						\item \textit{Functions should return values, not modify input objects}
						
						It is generally easier to validate if \texttt{float y} is the expected value of \texttt{float f(T x)}, than checking to see if \texttt{x.y} matches expectations after calling \texttt{void f(T \& x)}

						\item \textit{Complex Actions should have their own helper Functor}
						
						Rather than relying on writing a long method for (say) the Galaxy to handle the radial mixing prescription, give the Galaxy as \texttt{MixingHandling} object which can be called. Since this then separates out the radial mixing from the other state of the Galaxy, this allows for a more easy testing 

						\item \textit{Objects should have (static) factory methods}
						
						This allows us to initialise objects into a known state, and thereby test them (and apply tests to them) from controlled starting points

						\item \textit{Test early, test often}
						
						Each meaningful functional unit should have its own test - and the tests should be written (or at least, conceptualised) before the function itself is written. 
					\end{itemize}

				\subsubsection{Code Re-Use}

					Much of the code is dedicated to specialised scientific algorithms which is largely independent of the overarching software design.

					We're not throwing the baby out with the bathwater: these sections of the code are largely going to be perfectly functional. We do not need to rewrite, for example, the section of code dedicated to the generation of Stellar Yield Tables from SynthNet data: the algorithm is fine -- we just need to ensure that the final product is written into a new, compliant object, instead of a \texttt{std::vector<std::vector<std::vector<double>>>}, as it is currently.
					
					Where possible, therefore, we will try to re-use algorithmic code, wrapping it inside our new design paradigm.
				
				\subsubsection{Minimises JSL Dependence}
					
					The JSL library is good at what it does (which is act as a central repo for C++ code that I use all the time). 

					However, it's not particularly suitable for deployment into an external codebase. We should extract the useful parts and have them as part of the core Ramices sourcecode.

					\textcolor{red}{We should think about how much of JSL to port over. Do we want to include the JSL::gnuplot library to have plotting integrated into the simulation?} 
				\subsubsection{Input \& Output}
					The JSL::Argument package already does a reasonable job of allowing for runtime configuration of the simulation, through standard command-line arguments and configuration files. However, manually messing around with config files is irksome. Jack has already developed a fun python module which allows for easy construction of a config-file GUI. We should implement our own -- this requires no rewriting of the config-handling system, but is instead a system built 


	\newpage
		\section{Modular Design}
			
			In keeping with our design principle that a GCE simulation is a cohesive collection of disparate parts, we shall endeavour to write the code in a way which minimises the interactions between these distinct segments. This will make validation easier, and improve the modularity -- by minimising the interaction between units, we make it much more possible to `swap out' various units, and thereby extend this code to perform more physics than it was originally designed for! From a software design standpoint, it also isolates individual units which is a good design principle.

			Of course, it also means that we get to decide what to call each of the individual modules. That being said, I remember the annoyance of trying to remember what \texttt{ariadne} did versus \texttt{persephone}. The temptation to give everything fun, thematic names is great, but it's not sustainable in the long term. I suggest that modules have a `formal name' which describes what they do\footnote{And by sheer happenstance, happens to have a fun, Egyptian-thematic acronym.}, and a `code name', which is a short, snappy name used to refer to them in the code, even if it's not fully representative of what the module is doing.

			\newcommand\module[4]
			{
				\item[\texttt{#1}]					
				\def\temp{#3}
				\ifx\temp\empty
				
				\else
				(or, {\it #4}: \texttt{#3})
				\fi


				#2
			}
			\begin{description}	
			\module{ramices}
			{
				This is the main simulation module, and the focal point of the code. The RaMiCES module will incorporate all of the information form the other modules, and channel information from one module to another. 
			}{}{}
			\module{isochrone}
			{
				This module is responsible for the interpretation of Isochrone information. This is used at two points in the code: first for inferring the mass-lifetime relationship of stars and the (much more complex) task of inferring the properties of the stars at the end of the simulation, such that an observable catalogue can be synthesised.
				}{CLIO}{Computed Lifetimes \& Isochrone Observables}
			
			\module{yield}
			{
				This modules is responsible for computing the end-of-lifetime processes: the elemental composition of ejecta, as well as determining the nature of any remnants. It should be possible for this module to be lifted more or less wholesale from the original code -- given that the \RTwo{} implementation was already lifted out of the version I wrote for \texttt{R1}.
			}{MeRYT}{Metal \& Remnant Yield Tables}

			\module{population}
			{
				This module is the one which will probably require the most new theory, and comprises the module which generates the 
			}{OSyRIS}{Observation Synthesis, Reflecting Instrument Selection}

			\module{utility}
			{
				This is a basic module containing a bunch of `stuff' -- mainly the non-scientific portions of the code, such as loggers, parallel code execution, file readers and so on. The utility module is a basic grab-bag of functions which are used in multiple places. 
			}{THOTH}{Testers, Handlers, Operators, Templates \& Helpers}

			\module{test}
			{
				This is the unit test module. It is the most important module if we are committed to going ahead with a Test-Driven Development philosophy, and the one that should have considerable thought put into before the others. The test module is obviously unusual.
			}{ATeN}{Automated Testing Network}
			\end{description}
	\newpage
		\section{PyRamices}

			One potential issue with our `neater output' ideology\footnote{This will take the form of packaging the dozens of files into basic tarballs, for which I already have a neat C++ implementation} is that it makes post-processing of the data troublesome. Of course, since tarballs are common data-types, we could just expect users to un-tar when they want to access files -- but then files spill out all over the place, and we're back to square one.

			Given that we are already in the process of implementing a (Python-based) GUI framework for the code, the logical extension is to provide an entire wrapper environment. This would (largely) amount to a wrapper class and some aliased calls to the excellent pytar library. That way you can configure, run and then post-process the data, all from within python.

			An approximate design looks like this:
			\begin{center}
				\resizebox{\linewidth}{!}{
			\begin{tikzpicture} 
			\begin{umlpackage}[fill=white]{PyRamices and Ramices}
		
				\begin{umlpackage}[x=0,y=0,name={ramices}]{RAMICES} 
					
					\umlclass[x=0,y=0]{ConfigHandler}{}{+ readConfigFile()}
					\umlclass[x=10,y=0]{OutputHandler}{}{+ writeOutputFiles()}
					\umlclass[x=5,y=0]{Simulation}{- Reader : ConfigHandler 
					\\
					- Writer : OutputHandler}{+ DoComplexStuff()}
					\umlclass[x=10,y=-3]{TarWriter}{-Buffer : string}{+WriteToTar()}
					\umlcompo{Simulation}{ConfigHandler}
					\umlcompo{Simulation}{OutputHandler}
					\umluniassoc{TarWriter}{OutputHandler}

				\end{umlpackage}


				\begin{umlpackage}[x=5,y=5]{pyramices}
					\umlemptyclass[x=0,y=0]{Core}

					\umlemptyclass[x=-3,y=0]{config}
					\umlemptyclass[x=-6,y=1]{config-GUI}
					\umlassoc{config}{config-GUI}
					\umluniassoc{config}{Core}
					
					\umlemptyclass[x=4,y=0]{PostProcessor}
					\umlemptyclass[x=7,y=1]{PyTar}
					\umlemptyclass[x=3,y=2]{Maptlotlib}
					\umluniassoc{PyTar}{PostProcessor}
					\umluniassoc{Maptlotlib}{PostProcessor}
					\umluniassoc{PostProcessor}{Core}
					
				\end{umlpackage}
				
				\umlVHVassemblyconnector[with port,interface={config file~~~~~},anchor2=40,right]{config}{ConfigHandler}
				\umlVHVassemblyconnector[with port,interface={output files},anchor2=40,right]{PostProcessor}{OutputHandler}

				\end{umlpackage} 
				\end{tikzpicture}
				}
			\end{center}

			Functionally, all `pyramices' needs to do is generate config files, launch instances of the main simulation, and then read output files -- this is stuff we would be doing already, and so it cannot hurt to formalise it.

	\newpage

	\section{Diagrams}

	
	\begin{tikzpicture} 
		% \begin{umlpackage}{Overall Design} 

		\begin{umlcomponent}[fill=white]{RAMICES III}
		
		\begin{umlcomponent}[x=5,y=-3]{Main Simulation} 
			
		\end{umlcomponent}
		
		\begin{umlcomponent}[y=0]{ISIS}
			% \umlnote{ISIS}{Interpolated Stellar Isochrone States}
		\end{umlcomponent}

		\umlHVassemblyconnector[with port,interface={Isochrone File}]{Main Simulation}{ISIS}

		\begin{umlcomponent}[y=-6]{SET}
			% \textit{Stellar Ejecta Transmuter}
		\end{umlcomponent}

		\umlVHVassemblyconnector[with port,interface={Yield File},below]{Main Simulation-south-port}{SET}
		% \umlnote[y=3]{ISIS}{\textit{\scriptsize Interpolated Stellar Isochrone States}}
		\end{umlcomponent} 
		\end{tikzpicture}

		% \begin{landscape}
		\resizebox{\linewidth}{!}{
		\begin{tikzpicture} 
			\begin{umlpackage}{RAMICES}
				\umlclass[x=0,y=5]{Simulation}
				{
					-Galaxy : Galaxy
					\\
					-Sampler : StellarSampler
				}
				{
					+RunSimulation() : void
					\\
					+SamplePopulation(): void
				}

				\umlclass{Galaxy}{
					\# Rings : std::vector<Ring>
					\\
					\# Mixer : MigrationHandler
					\\
					- Reservoir : \& ExternalReservoir
				}
				{
					+ Evolve()
				}

				\begin{umlcomponent}[x=8,y=5]{CLIO}
					\umlclass{StellarSampler}{
							- SelectionFunction : ??
							\\
							- Isochrones : ??
						}
						{
							+ GetPopulation(galaxy : Galaxy)
						}
					
					

				\end{umlcomponent}
				\umlnote[x=9,y=9]{CLIO}{\textit{\scriptsize Calculate Lifetimes and Isochrone-Observables}}
				\umlrequiredinterface[distance=7cm,interface=isoFile]{CLIO}
				% 
				\umlHVHcompo{Simulation}{StellarSampler}
				\umlVHVassoc[anchor2=70]{StellarSampler}{Galaxy}
				\umlclass[x=8,type=Interface]{ExternalReservoir}{
					
				}
				{
					\umlvirt{+ProvideOnfall() : Gas}
					\\
					\umlvirt{+AcceptEjecta(Gas:): Gas}
				}

				
				\umlVHVcompo{Simulation}{Galaxy}
				% \umlVHVcompo{Simulation}{IGM}
				\umlcompo{Galaxy}{ExternalReservoir}

				\umlclass[width=1ex,x = 8,y=-5,]{Growth Manager}
				{
					- GrowthProfile : ??
				}
				{
					+ GetGrowth() : ??
				}


				\umlVHVcompo[anchor1=-70,anchor2=100]{Galaxy}{Growth Manager}
				\umlassoc[]{Growth Manager}{ExternalReservoir}

				\umlclass[width=1ex,x = 14,y=0,]{IGM}
				{
					\# Gas : Gas
				}
				{}

				\umlclass[width=1ex,x = 14,y=-3,]{NSDReservoir}
				{
					\# InjectionEnrichment : Gas
				}
				{}
				\umlimpl{IGM}{ExternalReservoir}
				\umlHVHimpl{NSDReservoir}{ExternalReservoir}

				\umlclass[width=1ex,x = -8,y=0,]{MigrationHandler}
				{
					- ScatteringMatrix : ??
				}
				{
					- ComputeScatteringMatrix(): void
					\\
					+ GetScattering() : ??
				}
				\umlcompo[]{Galaxy}{MigrationHandler}


				\begin{umlcomponent}[x=-8,y=-5]{MERYT}
					\umlclass{YieldGrid}{
							
						}
						{
						
						}
					
					

				\end{umlcomponent}
				\umlnote[x=-5,y=-8]{MERYT}{\textit{\scriptsize MEtal and Remnant Yield Tables}}
				\umlrequiredinterface[distance=7cm,interface=yieldFile]{MERYT}
			\end{umlpackage}
		\end{tikzpicture}
		}

		(Note: + is public, \# is protected and - is private)
		% \end{landscape}
	\end{document}