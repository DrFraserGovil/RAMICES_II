\documentclass[a4paper,10pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\usepackage{fullpage}
\usepackage{amsmath}
\usepackage{tikz-uml}
\usepackage{lscape}
\usepackage{pgfplots}
\usepackage{hyperref}
% \sloppy
% \hyphenpenalty 10000000
\setlength\parindent{0pt}
\setlength\parskip{10pt}
\usepackage{soul} 
\usepackage{xifthen}

\newboolean{completed}
\setboolean{completed}{false}
\newboolean{firstpass}
\setboolean{firstpass}{true}

\hypersetup{
    colorlinks,
    linkcolor={black},
    citecolor={blue!50!black},
    urlcolor={blue!90!black},
	filecolor={blue!90!black}
}

\title{RAMICES III}
\author{(JF)$^2$G}
\def\d{\mathrm d}
\newcommand\fitem[2]
			{
				\textbf{#1:} #2
			}
			\newcommand\citem[3][0]
			{
				\ifthenelse{\equal{#1}{1} \OR \boolean{completed}}
				{
					\ifthenelse{\NOT \boolean{firstpass}}
					{
						\item {\fitem{\st{#2}}{\st{#3}}}
					}{
					}
				}
				{
					\ifthenelse{\boolean{firstpass}}
					{\item \fitem{#2}{#3}}{}
					
				}
			}
			\def\emptyItem
			{
				\item[] \vspace{-20pt}
			}
			\newcommand\cparent[4][0]
			{
				\if#11
					\setboolean{completed}{true}
				\fi

				\ifthenelse{\equal{#1}{0} \AND \boolean{firstpass}}
				{
					\citem[#1]{#2}{#3}
					\begin{enumerate}
						#4
						\emptyItem{}
					\end{enumerate}
					\setboolean{firstpass}{false}
					\begin{enumerate}
						#4
						\emptyItem{}						
					\end{enumerate}
					\setboolean{firstpass}{true}
				}
				{
					\ifthenelse{\boolean{firstpass}}
					{}
					{
						\ifthenelse{\equal{#1}{1}}
						{
						\citem[#1]{#2}{#3}
					\begin{enumerate}
						#4
						\emptyItem{}
					\end{enumerate}
						}{}
					}
				}
				\setboolean{completed}{false}
			}

			\newcommand\fancyList[1]
			{
				\begin{enumerate}
					\setboolean{firstpass}{true}
					#1
					\setboolean{firstpass}{false}
					#1
					\emptyItem{}
				\end{enumerate}
			}

			\usepackage[framemethod=tikz]{mdframed}
			\mdfdefinestyle{mpdframe}{
				frametitlebackgroundcolor   =black!15,
				frametitlerule          =true,
					roundcorner     =10pt,
					middlelinewidth     =1pt,
					innermargin     =.20cm,
					outermargin     =0.2cm,
					innerleftmargin     =0.2cm,
					innerrightmargin        =0.2cm,
					innertopmargin      =\topskip,
					innerbottommargin   =\topskip,
						}
			%   Studies
			\mdfdefinestyle{a}{%
					style=mpdframe,
					frametitle={Aside},
				}
			\newmdenv[style=a]{aside}
\begin{document}
% \setcounter{tocdepth}{2}
\maketitle
% \tableofcontents
	\def\RTwo{\texttt{R2}}
	

		\section*{Oh no, here we go again}

			We're refactoring RAMICES. Again.

			Why? Why would we do this to ourselves? What on God's Green Earth would drive us to such extreme lengths, when we could be doing so much else with our lives?
			
			The long story short is that more than 3 years have passed since it was written: we've both learned a lot. There's also been a bit of space between its original design and the idea that it would have a lifetime outside of my thesis\footnote{My thesis made some grand claims about it being a general purpose code. Lies.}

			In particular, there was one big black mark that has hung over RAMICES II (\RTwo) which was the stellar catalogue synthesis: Jenny has since found a whole bunch of stuff that's basically held together by hope and good intentions - or simply not held together at all. 

			\subsubsection*{Don't Be So Dramatic}

				I'm being deliberately hyperbolic here. It's worth noting in writing that I don't expect this to be anywhere near as painful as the original Great Refactoring. \RTwo{} is leagues ahead of its predecessor in terms of being able to be read by a mortal mind without causing it to fragment into a trillion tiny pieces. 

				If all goes well, this will be a nice quick project that results in a vastly superior end product. Make a wish, children!

				
				
			\subsubsection*{What This Document Is}

				Ensuring that this new code update is swift, and non-brain melting means doing some work up front: an up-front statement of intent, and a record of our internal thoughts and decisions which lead to certain elements of the design. That way, when someone says `why is $X$ like $Y$', they can look at this document to understand those decision.

			\subsubsection*{What it isn't}
				
				This is \textbf{not} a checklist of everything that needs doing on a day to day basis. There will be a list of things that we think of at the start, but as new challenges arise, we'll track them using \href{{https://github.com/users/DrFraserGovil/projects/3/views/1}}{a more suitable project tracking system.}

		\newpage
		\section{Up Front Thoughts}

			
			The main argument we should justify in this document is why a complete code refactor is necessary, rather than simply `tidying up' the old code.

			I think we highlight that the following four things are the main target of RAMICES III:
			\begin{enumerate}
				\item \textbf{A Revised Population-Tracking Method} 
				
				\href{theory.pdf}{An attached theory document} details a major overhaul of the current mass-binning of stars. This requires a complete rewrite of the internal logic of the stellar tracking system

				\item \textbf{A Revised Stellar Catalogue System}
				
				The current system of synthesising stellar catalogues and selection functions has never been to my satisfaction.
				\item \textbf{Improved Modularity} 
				
				\RTwo{} is a drastic improvement over its predecessor in terms of being able to `plug and play' new modules\footnote{This is evidence by Jenny's NSD work, which remains astounding to me that it worked at all.}, but many things are still somewhat hardcoded and assumed, simply because they were necessary for the Thesis development.
				\item \textbf{More Sophisticated Development}
				
				\RTwo{} was written in three months of PhD-Crunch. It is not a particularly pretty sight, there is little to no internal documentation, and things such as the git history are best left unspoken-of. We should like to write these things with a mind to future maintenance and use by people who still have their sanity.
			\end{enumerate}

			\subsection{Other Design Thoughts}

				\subsubsection{Test-Driven Development}

					A risk of scientific software design is that you end up attributing some intriguing scientific interpretation to a software bug. Both \texttt{R1} and \RTwo{} are highly state-dependent systems with a lot of external state-modification. This can make debugging the system highly difficult, and allows for the possibility of strange and unusual software bugs. 
					
					When refactoring the code we should strive to adhere to the following principles:
					\begin{itemize}
						\item \textit{Functions should return values, not modify input objects}
						
						It is generally easier to validate if \texttt{float y} is the expected value of \texttt{float f(T x)}, than checking to see if \texttt{x.y} matches expectations after calling \texttt{void f(T \& x)}

						\item \textit{Complex Actions should have their own helper Functor}
						
						Rather than relying on writing a long method for (say) the Galaxy to handle the radial mixing prescription, give the Galaxy as \texttt{MixingHandling} object which can be called. Since this then separates out the radial mixing from the other state of the Galaxy, this allows for a more easy testing 

						\item \textit{Objects should have (static) factory methods}
						
						This allows us to initialise objects into a known state, and thereby test them (and apply tests to them) from controlled starting points

						\item \textit{Test early, test often}
						
						Each meaningful functional unit should have its own test - and the tests should be written (or at least, conceptualised) before the function itself is written. 
					\end{itemize}

				\subsubsection{Code Re-Use}

					Much of the code is dedicated to specialised scientific algorithms which is largely independent of the overarching software design.

					We're not throwing the baby out with the bathwater: these sections of the code are largely going to be perfectly functional. We do not need to rewrite, for example, the section of code dedicated to the generation of Stellar Yield Tables from SynthNet data: the algorithm is fine -- we just need to ensure that the final product is written into a new, compliant object, instead of a \texttt{std::vector<std::vector<std::vector<double>>>}, as it is currently.
					
					Where possible, therefore, we will try to re-use algorithmic code, wrapping it inside our new design paradigm.
				
				\subsubsection{Minimises JSL Dependence}
					
					The JSL library is good at what it does (which is act as a central repo for C++ code that I use all the time). 

					However, it's not particularly suitable for deployment into an external codebase. We should extract the useful parts and have them as part of the core Ramices sourcecode.

					\textcolor{red}{We should think about how much of JSL to port over. Do we want to include the JSL::gnuplot library to have plotting integrated into the simulation?} 
				\subsubsection{Input \& Output}
					The JSL::Argument package already does a reasonable job of allowing for runtime configuration of the simulation, through standard command-line arguments and configuration files. However, manually messing around with config files is irksome. Jack has already developed a fun python module which allows for easy construction of a config-file GUI. We should implement our own -- this requires no rewriting of the config-handling system, but is instead a system built 


	\newpage
	% % \section{Service-Layer Design}


	\newpage

	\section{Diagrams}

	
	\begin{tikzpicture} 
		% \begin{umlpackage}{Overall Design} 

		\begin{umlcomponent}[fill=white]{RAMICES III}
		
		\begin{umlcomponent}[x=5,y=-3]{Main Simulation} 
			
		\end{umlcomponent}
		
		\begin{umlcomponent}[y=0]{ISIS}
			% \umlnote{ISIS}{Interpolated Stellar Isochrone States}
		\end{umlcomponent}

		\umlHVassemblyconnector[with port,interface={Isochrone File}]{Main Simulation}{ISIS}

		\begin{umlcomponent}[y=-6]{SET}
			% \textit{Stellar Ejecta Transmuter}
		\end{umlcomponent}

		\umlVHVassemblyconnector[with port,interface={Yield File},below]{Main Simulation-south-port}{SET}
		% \umlnote[y=3]{ISIS}{\textit{\scriptsize Interpolated Stellar Isochrone States}}
		\end{umlcomponent} 
		\end{tikzpicture}

		% \begin{landscape}
		\resizebox{\linewidth}{!}{
		\begin{tikzpicture} 
			\begin{umlpackage}{RAMICES}
				\umlclass[x=0,y=5]{Simulation}
				{
					-Galaxy : Galaxy
					\\
					-Sampler : StellarSampler
				}
				{
					+RunSimulation() : void
					\\
					+SamplePopulation(): void
				}

				\umlclass{Galaxy}{
					\# Rings : std::vector<Ring>
					\\
					\# Mixer : MigrationHandler
					\\
					- Reservoir : \& ExternalReservoir
				}
				{
					+ Evolve()
				}

				\begin{umlcomponent}[x=8,y=5]{CLIO}
					\umlclass{StellarSampler}{
							- SelectionFunction : ??
							\\
							- Isochrones : ??
						}
						{
							+ GetPopulation(galaxy : Galaxy)
						}
					
					

				\end{umlcomponent}
				\umlnote[x=9,y=9]{CLIO}{\textit{\scriptsize Calculate Lifetimes and Isochrone-Observables}}
				\umlrequiredinterface[distance=7cm,interface=isoFile]{CLIO}
				% 
				\umlHVHcompo{Simulation}{StellarSampler}
				\umlVHVassoc[anchor2=70]{StellarSampler}{Galaxy}
				\umlclass[x=8,type=Interface]{ExternalReservoir}{
					
				}
				{
					\umlvirt{+ProvideOnfall() : Gas}
					\\
					\umlvirt{+AcceptEjecta(Gas:): Gas}
				}

				
				\umlVHVcompo{Simulation}{Galaxy}
				% \umlVHVcompo{Simulation}{IGM}
				\umlcompo{Galaxy}{ExternalReservoir}

				\umlclass[width=1ex,x = 8,y=-5,]{Growth Manager}
				{
					- GrowthProfile : ??
				}
				{
					+ GetGrowth() : ??
				}


				\umlVHVcompo[anchor1=-70,anchor2=100]{Galaxy}{Growth Manager}
				\umlassoc[]{Growth Manager}{ExternalReservoir}

				\umlclass[width=1ex,x = 14,y=0,]{IGM}
				{
					\# Gas : Gas
				}
				{}

				\umlclass[width=1ex,x = 14,y=-3,]{NSDReservoir}
				{
					\# InjectionEnrichment : Gas
				}
				{}
				\umlimpl{IGM}{ExternalReservoir}
				\umlHVHimpl{NSDReservoir}{ExternalReservoir}

				\umlclass[width=1ex,x = -8,y=0,]{MigrationHandler}
				{
					- ScatteringMatrix : ??
				}
				{
					- ComputeScatteringMatrix(): void
					\\
					+ GetScattering() : ??
				}
				\umlcompo[]{Galaxy}{MigrationHandler}


				\begin{umlcomponent}[x=-8,y=-5]{MERYT}
					\umlclass{YieldGrid}{
							
						}
						{
						
						}
					
					

				\end{umlcomponent}
				\umlnote[x=-5,y=-8]{MERYT}{\textit{\scriptsize MEtal and Remnant Yield Tables}}
				\umlrequiredinterface[distance=7cm,interface=yieldFile]{MERYT}
			\end{umlpackage}
		\end{tikzpicture}
		}

		(Note: + is public, \# is protected and - is private)
		% \end{landscape}
	\end{document}